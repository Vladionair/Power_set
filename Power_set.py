gAAAAABfUUTv4NXY_F-UksIywOM1PCKuwOKT-arFgtSAlUUl3vivlhV6q3vel86C34srybwN5ogPQBk3dA_l4sOCnSGa5xGkChX-eFbc77-pN_lM_XAwYb1EtLpkrd9-Vk4VX4N6_EzVBEEu2OAQpY1zbq-83fNo0xSrVsRf92LpL2Vk-EnMxeEPA7cupBqkMwK2icMb6aBoYBqoyaxKyJqcBtqvzB9G95xYkC2w_A0BhmLeillOuvlURp4A_cKhbd-tojufIckWQpHJJg-MxN-nDpuHsQHgpADCRCI28YSzku1sZbRWuQQ_o4Jj4ZEyn4y0sCSnOW2qNO1vp_ffbFCd69BY87j28zaFWAtttoY6lRJMGWNpGyHFh2JvLJszb9Vcm7arf4obGzgxkftcFapDTpDTuhjtOaXj_qR5jnKXDJxL01uRFmIxaWXSpe86S4zsYj7IzLtncsO-JsCkMmUx54on1nzQPqRmnymwPPbD4m2Yk6TjmsEpBPxBQP9LIEYRBCp0LA7wFpqU2m45_enviIoRieRWP9BD0Ep8m-C-hBLSB1rWnn6S3oUUTOTSP1aqCubI1qTxkyDnuwoXBOdE5FHYavpjHi4xnPVR8f2zRud7iOH6DbwOZvw_etWVfKjyFLPHPPbLSuqRGnGTGeiBDUADEzBWqNQZP04BsKN0jZj8eiOmAZRTfKAu939K2MRug3-VfL0bCe0jv5PpVYepT9LlV4VwTOyK_Lf61l_gLSVoR8i0EhOrQqZXLHriPaZ1_YOENSCiYduHGQKTZWWLVdMJ0OkqYjg1WMGVDRM7dtfcr1jgijOQ8gshdEYk17xVS3Basj-eB8ZjskQlWf0dRyubuJJA8vczXfbY44FWrdiEWJYjwPHgh68kD5bv5Fd3pryj_lJJR8_iBs3qSxwns-MEFicWVvmrkwhfvczLBo9k96j9nLmP-BHkz4yxwhWvJk47PjiBQZeSA2aE-vrOBgU1KiyB6bW16QQpk81NBYygQAAhkWXKHvgpqSPus04XbQfN-wgz6EihbPr49UkWg4aQjnaUtbvNoi0QoLc6ykLp1GTSBSoMULl3k3cE5-uWgoPU29pF_kaplmKQEnR3xRT9vJqR_NI0eTkIJzh-ZR1wywiKzgDeaUo0SzIXRBHK_Q5O0uczMI73_webSQ0o6_2jPUZhIe7kDHNN1B_BE61fK8_EN90-Pg-3gLr0dtcILudHi7GDZ_aZWqPjLOXXqeZfcbOTHHfXJipwDfTk8D1-2VFvPDVliJW4CN2PUoa4LRJVvdY0Uj_MbqPEnWhGja6T5OWMN-uV7QBNwqNi5UkIgvjuTToywAakPC2GzgX4onVjdlKyDOczQ61beAYdkcjUihc7UGrD8ngsS2_h7HLFjuop_Da2Wpl3KxjrcIV5SZHYj5ettYwFkWwklcfOm-c6fQVHgPsPsR3u40_P0nMiBOccOoZQ7bN1DsrEQuiWSYW-ME1xcgd7l67jX-f5h-PABa6thNlD3WpEKC3FRTkr_0NqeYHu-znukFOoUvZmiHaK5j8sjaqxwIgUjolYhF-ZksK5nmy9dQbZzl5rvhw68DwRXJ6s9e1DIZK1MTUr96f7uzzQSr_6jTVMBe_iDN-zqSJc32vSyAwlSbOT5y0sw8HgTwyKboCH480X_B3ptqUEZJeoxa7f91YeMOvSL3G26SVvaySQt4HzQ1A-oIcVsc8crmL9yyeBxRIJMUTOmVbWmjyLZonHLtRYpigjs2gaVonsTXRFxOqhIbn9YDAgwJgBnmlf_qT9Cahdmsklil_kK5ke7Xn1pHUGoRTcV-2T0sRjlDo0FOAGkdf6e3BlIf_GYL8oBbhlcxizMtxBDmlOqbf_qQ5y35zi2r_cCYvYaQKXyqOhPDZyq-TSsKuJsyH8aGCrofG2N-_zMQi3F2MDbhSCjj1ACQmU1JBACHUj0t7WjHfMoXYgOBPpOOUiILvlkTJmCTWdcEkaUqabUsthC7RSJPEJEbO4qYueGnPKg9mAL5gr2042IzlGEzWyP_ncN4no_zIUhg6oAyn6ZT70p-TtqujKt0v0eU1H1KmVXFjVtKn3sOuEULv4dPVFPvSML6Jzyea6Kakx5T3uq9KF-CQAFkLuOKqL3AJztDpv4GSykf16cOYnmowwyCQxiARhDXBcoJI5CYXOlBuCt-CnU-2nIJS1t4VkeiK_p5IepaO8xzervwM4ZklI4u-qNEcJacGwIE1EfM0s6YNcq8JdMstyXYyAY-Xi-xYYr5OdEhwX88xyHp5gq-K_H-IEZCq1sGrPpz8BFmGfagPexzzfFEy9kyvuwUxImUdn2SAA7WPup-XTjztDRnEHe9poZjVs9xSYdQMRq1IfPVA3sD4K-HWHWe2vguBgR8rbxb4YGxlzOUVA0APP9Ofj29EJBocMQ526sLEx3wwADPC8WTqp-MZs59vAZq9rmfxDx-MkYsMsxwg9Rjx1_G1h_e-mAbOEkknNAC14Ec2uRPPJWIMOIEAIa6e4BRJGV8-c2IsGm_dAu9IsL_0vsu3Y9n3yHX2Qd_yFntEDgpaadbFkHQuw3qymR6O_D35_vzC-xNq5CQwNHnxtdUeFRgozELSk7BnpN60uj80ZKIL3QNOcrXEWHfdO4SC-SraQXFXeIu6oEo5UkN1JltIZ9KQO75CC3Zx79p1iIlRdndt_sfFZlkN-bJ9Yey-N5ZhLIkESQxSmmYmAGG5wKwF6GSFUV8HHzU_kKPyBQK0t2LbZKtKSkvyZKTmcoTm1JrHN-a1seEQLVlqSyjCS3k-yJgNVihpHE_-ZSPNUyRfBT7VdXZUuxW3CfPMrjTX8acHbbsjvYjsQtIs367QP-i81fMxXGkymnMbYOSPmPghbT7gdm670ZVrpaC5171jL9VF-Bvt_fe37fkzmlLTr3J8MSAeJWAXxCEGq_o7NpgFMeY2OkuDMTrj7eWuNW72u7GXv-I4TFJCVywMzOIZYyL7dMiuSVYBD2e9TP5rJrytk_PGEI02WdrXsdhUvgH0syjyfUgAB2BaHTsmMXDRPen7Zy4egTG7Jmrm_ULF0kCFd9eJ_6OpMog9lzKlBBcPDdeC9R8dYIggWTcz4BGGWXyVEkM7fbcQklbUq2ukcDWUBZmy1LCYfC99sY_Csh1S2CW_uZP1Zuy3lNi8OQcxArq_MEG7RDMvcXgMYy-UzAqumh6_NvOrOPTLndhaXlLTR2yxsc5Qqm6vudSCPLCZhu4EeGebSXaYWkiZGHX28iW5qOc15gO88swHa6xz9RbPZuBjnT9b7JgzwEWZWuFqjt2r-1R763rNRKn9Xy2vGt5WjBCjRFmmPmR62hvxhr0OEQMsLnWARECO-drgPQRztsINO9jcP0e-mJrD0UJk_8srlTRbQ_apD68kpVZY_uu9rQPRuNSx1DhQCOVxZpR9ZjbNuazmj2ZE5zm5LXqaDIocGOex9pF09dJZtsMfltAvP3ns8z_bA5yNpya2GdMFULxTcFXccu1csArO_9GXdXkQCZZglsKyTgrIRL5GivU4EPXV3ZnfcrJQI_b1YtCN-nnSIp8YiguDczgADZtdqGjJT2JUF0hW1FvlDeMXuK9YZoNrEgVuSsomBi6004mhMm7A_NSKPYSzo9rIkKkkG0no5OY7EzYgxiOKMva6r2t0J4ya7aLB4_yFOwj7bCaKMEN2uRSwDyXrWjvoItMLQaCKfszTib79BgrGNjUz97F9LdgYEfeMfLl7tiVGiIjIQUokisZ-CZLg1XqasNk02t5UZDtSDAQMQZv8tQq-h8ImZOUJAhyxK_Sne834gEruKq_-NUSyDq1RnbKTFONIK18T-pST8xsOrO20ma0eYjx3IJJprF5gJA-pt-KrVCBOJozy9A3nHkdxvqX-jk2PheMSKFyCjBIV_DYKu7c_4nku45WK8hL43wROFtgqt_XUXj-32b_z2kB-WI8F5d0TrKZNEnE-y-QDvGqU0COex5D3C5mDtvrHwKLii5pYpKudQLGDAZhMwQ3i9FAF1PCjYZ4hosUSaZH06HH_biKQwTdHetYn3fxbVooxs0XL6D6Z6Aa1rec8f5qzKTU1Xsfu6rlcMk9nAgM24EmZfByh9AZ-XBOyq6ceXXEJ4oGVXx9DpTFzyZa5r5AeXHJ0ppQ8PTKUdZVNoAxJNAmRM2m0JcyTowzxSUTleJeAm_8ncWbGL_msBzjfLaz3dc8ow1nrPA1DnD-ZWO59bcfEEYzlwG7Jk2g5L6MQq3D8a6dgq3h3ppsTC6dIcqTIeNQROKnshQfytD75cSWJGYDM50MJwomX64RROUlW9jSyxXnXsaTC2UzYhUYAfjC4NF4HWkE_rYRpWOvqLU0HXHZQA32Dy7hMGvxNIzynJ838rAmIiqrMo9oYDxB9kb6ojvsdpupGc4FNbvfg4iqCD0KM_vyYxo4y4dtmlJ32meqr90chRzM7EKhiB8OZ-BbHEGck2H1erJZgeg-7wqB42ilM3LS9egGwKgespZ2nnxWiBs9JMRlEYJet_8ct0f-ZbeA6MDneedTF_zpFlgCv8AQB5hCGP6P1mX0H4lmIbJ_YUMK5pg1vaP16XzsidTTh9RLjXpi6-fvJCBn9helmIsGLXb5H_

class PowerSet:

    def __init__(self):

        self.set = []

    def size(self):

        return len(self.set)

    def put(self, value):

        if value in self.set:
            raise KeyError
        else:
            return self.set.append(value)

    def get(self, value):

        if value in self.set:
            return True
        else:
            return False

    def remove(self, value):

        if value in self.set:
            self.set.remove(value)
            return True
        else:
            return False
            
    def intersection(self, set2):

        result = PowerSet()
        result.set = [i for i in self.set if i in set2.set]
        return result 

    def union(self, set2):

        result = PowerSet()
        result.set = [i for i in self.set if i not in set2.set] + set2.set
        return result
        
    def difference(self, set2):

        result = PowerSet()
        result.set = [i for i in self.set if i not in set2.set]
        return result
            
    def issubset(self, set2):

        result = [i for i in set2.set if i in self.set]
        if len(result) == len(set2.set):
            return True
        else:
            return False
            
import unittest

class Test_PowerSet(unittest.TestCase):
    
    def test_put(self):
      
        for i in range(10):
            inst_I.put(i)
            self.assertIn(i, inst_I.set)
        for i in range(10):
            self.assertRaises(KeyError, inst_I.put, i)
    
    def test_remove(self):

        for i in range(10):
            inst_I.put(i)
            self.assertEqual(inst_I.size(), 1 + i)
        for i in range(10):
            inst_I.remove(i)
            self.assertEqual(inst_I.size(), 9 - i)

    def test_intersection(self):

        for i in range(5):
            inst_I.put(i)
        for i in range(10):
            inst_II.put(i)
        for i in range(10):
            inst_III.put(i + 5)
        self.assertEqual(inst_I.intersection(inst_III).set, [])
        inst_I.__init__()
        for i in range(5):
            inst_I.put(i)
        self.assertEqual(inst_I.intersection(inst_II).set, inst_I.set)
        
    def test_union(self):

        for i in range(5):
            inst_I.put(i)
        for i in range(10):
            inst_II.put(i)
        self.assertEqual(inst_I.union(inst_II).set, inst_II.set)
        self.assertEqual(inst_I.union(inst_III).set, inst_I.set)
        
    def test_difference(self):

        for i in range(5):
            inst_I.put(i)
        for i in range(10):
            inst_II.put(i)
        for i in range(9, 4, -1):
            inst_III.put(i)
        self.assertEqual(inst_I.difference(inst_I).set, [])
        self.assertEqual(inst_II.difference(inst_I).set.sort(), inst_III.set.sort())
        
    def test_issubset(self):

        for i in range(10):
            inst_I.put(i)
        for i in range(5):
            inst_II.put(i)
        for i in range(-1, 5, 1):
            inst_III.put(i)
        self.assertTrue(inst_I.issubset(inst_II))
        self.assertFalse(inst_II.issubset(inst_I))
        self.assertFalse(inst_I.issubset(inst_III))

    def tearDown(self):

        inst_I.__init__()
        inst_II.__init__()
        inst_III.__init__()

if __name__ == '__main__':
  
    inst_I = PowerSet()
    inst_II = PowerSet()
    inst_III = PowerSet()
    unittest.main(verbosity=2)
